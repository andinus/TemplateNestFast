#+title: Template::Nest::Fast
#+subtitle: manipulate a generic template structure via a Raku hash

* Documentation

~Template::Nest::Fast~ is a high-performance template engine module for
Raku, designed to process nested templates quickly and efficiently.
This module improves on the original ~Template::Nest~ module by caching
the index of positions of variables, resulting in significantly faster
processing times.

For more details on ~Template::Nest~ visit:
https://metacpan.org/pod/Template::Nest

Note: This module was created by me as a proof-of-concept to benchmark
against ~Template::Nest::XS~. Tom Gracey (virtual.blue) is currently
sponsoring for the development of this module. He authored
~Template::Nest~ originally in Perl 5.

** Options

Compatibility Progress:
#+begin_src
[X] comment_delims
[X] defaults
[X] defaults_namespace_char
[X] die_on_bad_params
[ ] escape_char             - Won't be implemented
[X] fixed_indent
[X] name_label
[X] show_labels
[X] template_dir
[X] template_ext
[X] token_delims
#+end_src

- Note: ~escape_char~ has been replaced with ~token-escape-char~.
- Note: ~cache-template~ option has been added and is enabled by default.

- ~name-label~ (default ~TEMPLATE~): Represents the label used for
  identifying the template name in the hash of template variables.

- ~template-dir~: IO object representing the directory where the
  templates are located.

- ~cache-template~ (default: ~True~): If True then the whole template
  file is cached in memory, this improves performance.

- ~die-on-bad-params~ (default: ~False~): If True, then an attempt to
  populate a template with a variable that doesn't exist (i.e. name
  not found in template file) results in an error.

  Note that it allows to leave variables undefined (i.e. name found in
  template file but not defined in template hash). Undefined variables
  are replaced with empty string. This is for compatibility with
  Template::Nest (Raku).

  You might want to keep this enabled during development & testing.

- ~show-labels~ (default: ~False~): If True, an string is appended to
  every rendered template which is helpful in identifying which
  template the output text came from. This is useful in development
  when you have many templates.

  Example:
  #+begin_src html
<!-- BEGIN 00-simple-page -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simple Page</title>
  </head>
  <body>
    <p>A fairly simple page to test the performance of Template::Nest.</p>
    <p>Simple Variable</p>
    <!-- BEGIN 01-simple-component -->
<p>Simple Variable in Simple Component</p>
<!-- END 01-simple-component -->
  </body>
</html>
<!-- END 00-simple-page -->
  #+end_src

  Here, 'BEGIN' & 'END' blocks have been added because ~show-labels~
  was set to True.

  If you're not templating HTML and still want labels, you can set
  ~comment-delims~.

- ~comment-delims~ (default: ~['<!--', '-->']~): Use this in
  conjunction with ~show-labels~. Expects a 2 element array. Example,
  for templating JS you could do:

  #+begin_src raku
my $nest-alt = Template::Nest::Fast.new(
    :$template-dir, :show-labels, comment-delims => ['/*', '*/']
);
  #+end_src

  Example output:
  #+begin_src js
/* BEGIN js-file */
...
/* END js-file */
  #+end_src

  You can set the second comment token as an empty string if the
  language you are templating does not use one. Example, for
  templating Raku you could do:

  #+begin_src raku
my $nest-alt = Template::Nest::Fast.new(
    :$template-dir, :show-labels, comment-delims => ['#', '']
);
  #+end_src

  Example output:
  #+begin_src raku
# BEGIN raku-file
...
# END raku-file */
  #+end_src

- ~template-extension~ (default: ~html~): get/set the template
  extension. This is so you can save typing your template extension
  all the time if it's always the same. There is no reason why this
  templating system could not be used to construct any other type of
  file (or why you could not use another extension even if you were
  producing html). Example, to manipulate JavaScript files, this will
  look for ~30-main.js~ in ~$template-dir~:

  #+begin_src raku
my $nest-js = Template::Nest::Fast.new: :$template-dir, :template-extension('js');
my %simple-page-js = %(
    TEMPLATE => '30-main',
    var => 'Simple Variable',
);
  #+end_src

  Or if you have an empty ~template-extension~, this will look for
  ~30-main.html~ in ~$template-dir~:
  #+begin_src raku
my $nest = Template::Nest::Fast.new: :$template-dir, :template-extension('');
my %simple-page-js = %(
    TEMPLATE => '30-main.html',
    var => 'Simple Variable',
);
  #+end_src

- ~fixed-indent~ (default: ~False~): Intended to improve readability
  when inspecting nested templates. For example, consider these templates:

  wrapper.html:
  #+begin_src html
<div>
    <!--% contents %-->
</div>
  #+end_src

  photo.html:
  #+begin_src html
<div>
    <img src='/some-image.jpg'>
</div>
  #+end_src

  Output without ~fixed-indent~:
  #+begin_src html
<div>
    <div>
    <img src='/some-image.jpg'>
</div>
</div>
  #+end_src

  Output with ~fixed-indent~:
  #+begin_src html
<div>
    <div>
        <img src='/some-image.jpg'>
    </div>
</div>
  #+end_src

- ~token-delims~ (default: ~['<!--%', '%-->']~): Set the delimiters
  that define a token (to be replaced). For example, setting
  ~token-delims~ to ~['<%', '%>']~ would mean that ~render~ will now
  recognize and interpolate tokens in the format:

  #+begin_src
<% variable %>
  #+end_src

- ~token-escape-char~ (default: empty string): On rare occasions you
  may actually want to use the exact character string you are using
  for your token delimiters in one of your templates. For example,
  here ~render~ is going to consider this as a token and remove it:

  #+begin_src
did you know we are using token delimiters <!--% and %--> in our templates?
  #+end_src

  To include the token, escape it with ~token-escape-char~ set to
  (~\~):
  #+begin_src
did you know we are using token delimiters \<!--% and %--> in our templates?
  #+end_src

  Set it to an empty string to disable the behaviour.

- ~defaults~: Provide a hash of default values that are substituted if
  template hash does not provide a value. For example, passing this
  defaults hash:

  #+begin_src raku
my $nest = Template::Nest::Fast.new(
    :$template-dir,
    defaults => %(
        variable => 'Simple Variable',
        space => %(
            inside => 'A variable inside a space.'
        )
    ),
);
  #+end_src

  This ~$nest~ will first look for variable in template hash, then in
  ~%defaults~ hash. If no value is found then namespaced defaults are
  considered (look ~defaults-namespace-char~).

- ~defaults-namespace-char~ (default: ~.~): Say you want to namespace
  values in ~%defaults~ hash to differentiate parameters coming from
  template hash and chose to prefix those variables like so:

  #+begin_src html
<!--% config.title %--> - <!--% config.description %-->
  #+end_src

  You can pass a defaults like:
  #+begin_src raku
%(
    "config.title" => "Title",
    "config.description" => "Description"
)
  #+end_src

  However, writing ~config.~ repeatedly is a bit effortful, so you can
  do the following:
  #+begin_src raku
%(
    config => %(
        "title" => "Title",
        "description" => "Description"
    )
)
  #+end_src

  Note: To disable this behaviour set ~defaults-namespace-char~ to an
  empty string.

** Methods

- ~render~: Converts a template structure to output text. See Example
  for details.

** Example

This is a simple example that injects a variable in a template. We use
another template as a component as well.

#+begin_src raku
use Template::Nest::Fast;

# Create a nest object.
my $nest = Template::Nest::Fast.new( template-dir => 'templates/'.IO );

# Declare template structure.
my %simple-page = %(
    TEMPLATE => '00-simple-page',
    variable => 'Simple Variable',
    simple_component => %(
        TEMPLATE => '01-simple-component',
        variable => 'Simple Variable in Simple Component'
    )
);

# Render the page.
put $nest.render(%simple-page);
#+end_src

Templates:
~templates/00-simple-page.html~:
#+begin_src html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simple Page</title>
  </head>
  <body>
    <p>A fairly simple page to test the performance of Template::Nest.</p>
    <p><!--% variable %--></p>
    <!--% simple_component %-->
  </body>
</html>
#+end_src

~templates/01-simple-component.html~:
#+begin_src html
<p><!--% variable %--></p>
#+end_src

Output:
#+begin_src html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simple Page</title>
  </head>
  <body>
    <p>A fairly simple page to test the performance of Template::Nest.</p>
    <p>Simple Variable</p>
    <p>Simple Variable in Simple Component</p>
  </body>
</html>
#+end_src

* News

** v0.2.0 - 2023-05-02

+ Achieved options compatibility with Template::Nest (Raku).
+ Added several options:
  - ~cache-template~
  - ~die-on-bad-params~
  - ~show-labels~
  - ~comment-delims~
  - ~template-extension~
  - ~fixed-indent~
  - ~token-delims~
  - ~token-escape-char~
  - ~defaults~
  - ~defaults-namespace-char~

+ Note: It's not backwards compatible with Template::Nest (Raku).

** v0.1.0 - 2023-03-28

+ Initial Release.

* See Also

- Template::Nest [Perl5] https://metacpan.org/pod/Template::Nest
- template-nest [Python] https://pypi.org/project/template-nest/
- Template::Nest [Raku] https://raku.land/cpan:TOMGRACEY/Template::Nest
- Template::Nest::XS [Raku] https://raku.land/zef:jaffa4/Template::Nest::XS
